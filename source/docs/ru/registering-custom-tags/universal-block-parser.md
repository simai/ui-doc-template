---
extends: _core._layouts.documentation
section: content
title: 'Универсальный парсер блоков'
description: 'Универсальный парсер блоков'
---

# Универсальный парсер блоков

Этот парсер отвечает за распознавание пользовательских **блок** (`!type` … `!endtype`), создавая узлы AST и делегируя анализ внутреннего содержимого конвейеру CommonMark.

---

## Местоположение и подпись
- Пространство имен: `App\Helpers\CommonMark`
- Класс:`UniversalBlockParser`

---

## Роль в воронке продаж
- Установка `CustomTagExtension`.
- Выполняется во время определения начала блока для каждой строки.
- За каждого зарегистрированного `CustomTagSpec`, он пытается соответствовать **открытый** регулярное выражение на текущей строке. На успех это:
    1) Строит `CustomTagNode` с объединенными атрибутами и метой;
    2) Возвращает контейнер **продолжить парсер** который:
        - Принимает любые дочерние блоки/встроенный контент;
        - Заканчивается, когда **закрывать** Регулярное выражение сопоставляется (или сразу для однострочных тегов).

---

## Конструктор
```php
public function __construct(private CustomTagRegistry $registry) {}
```
Принимает команду **регистратура** в котором представлен список `CustomTagSpec` Экземпляров: `{ type, openRegex, closeRegex, allowNestingSame, baseAttrs, attrsFilter }`.

---

## `tryStart()` — шаг за шагом
```php
public function tryStart(Cursor $cursor, MarkdownParserStateInterface $state): ?BlockStart
```

1. **Читать текущую строку**
   ```php
   $line = $cursor->getLine();
   ```
2. **Попробуйте каждую спецификацию** В реестре сопоставляем открытый маркер
   ```php
   if (!preg_match($spec->openRegex, $line, $m)) continue;
   ```
3. **Правило вложенности** для однотипных блоков
    - Если активным блоком является `CustomTagNode` с тем же `type` и `allowNestingSame === false`, новый старт - это **Подавлены**:
   ```php
   return BlockStart::none();
   ```
4. **Потребляйте всю линейку**
   ```php
   $cursor->advanceToEnd();
   ```
5. **Атрибуты синтаксического анализа** из названной группы `attrs` и **сливать** со спецификациями по умолчанию
   ```php
   $attrStr   = $m['attrs'] ?? '';
   $userAttrs = Attrs::parseOpenLine($attrStr);
   $attrs     = Attrs::merge($spec->baseAttrs, $userAttrs);
   ```
6. **Создать узел** с мета
   ```php
   $node = new CustomTagNode($spec->type, $attrs, [
       'openMatch' => $m,
       'attrStr'   => $attrStr,
   ]);
   ```
7. **Ранняя фильтрация атрибутов (опционально)**
    - Если спецификация предусматривает `attrsFilter`, это применяется **немедленно** к атрибутам ноды:
   ```php
   if ($spec->attrsFilter instanceof \Closure) {
       $node->setAttrs(($spec->attrsFilter)($node->getAttrs(), $node->getMeta()));
   }
   ```
   **Примечание к подписи:** `attrsFilter` вызывается с помощью **Два аргумента** `($attrs, $meta)` где `meta` содержит не менее `openMatch` и `attrStr`.
8. **Возврат парсера контейнеров** (аноним `AbstractBlockContinueParser`), который:
    - `getBlock()` возвращает метод `CustomTagNode`.
    - `isContainer()` есть `true` — разбирается внутреннее содержимое **как обычно Markdown**.
    - `canContain()` Возвращает `true` — принимает любых детей.
    - `canHaveLazyContinuationLines()` есть `false` — только явные строки.
    - `tryContinue()` завершается, когда **закрывать** регулярное выражение совпадает с текущей строкой (и поглощает строку); в противном случае продолжается.

---

## Поведение при закрытии
```php
if ($this->spec->closeRegex === null) {
    return BlockContinue::finished(); // single-line tag
}

if (preg_match($this->spec->closeRegex, $line)) {
    $cursor->advanceToEnd();
    return BlockContinue::finished();
}
```
- **Однострочные теги**:если `closeRegex` есть `null`блок заканчивается сразу после открытой строки (без внутреннего содержимого).
- **Стандартные блоки**: блок остается открытым до тех пор, пока не совпадет строка `closeRegex` (`!end<type>` по умолчанию). Строка закрытия используется и не передается как содержимое.

---

## Вложенная семантика
- Если`allowNestingSame` есть **ложный** и активным блоком является **Однотипный**, внутренний открытый — это **Игнорировать** (рассматривается как обычный текст до внешнего закрытия).
- Различные типы тегов по-прежнему могут свободно вкладываться, так как `canContain()` Возвращает `true`.

---

## Атрибуты и мета
- Атрибуты анализируются из открытой строки через `Attrs::parseOpenLine()` поддерживающий:
    - Пары ключ-значение: `key="value"`, `key:'value'`, токены без котировок
    - Сокращения: `.class` Присоединяется к `class`, `#id` Задает `id`
    - Нормализуются пробелы в Юникоде и смарт-кавычки; Дедупликация классов
- Слияние выполняется с помощью `Attrs::merge($spec->baseAttrs, $userAttrs)`.
- **Мета** Хранится на узле:
    - `openMatch` — полный массив совпадений регулярных выражений для `openRegex`
    - `attrStr` — необработанная подстрока атрибута из начальной строки

> Реализуйте свой `attrsFilter` как `fn(array $attrs, array $meta): array` , чтобы использовать эту информацию (например, получить атрибуты из групп захвата).

---

## Обязанности контейнера
Внутренний анонимный парсер continue parser:
- **Не** Сбор строк текста сам (`addLine()` не работает);
- **Делегаты** разбор внутреннего содержимого в стандартные блочные/инлайн парсеры, так как он помечен как контейнер, принимающий любых дочерних элементов;
- **сигналов закрытия** дорога `tryContinue()` когда `closeRegex` спички.

---

## Пограничные случаи и поведение
- **Незакрытый блок в EOF**: CommonMark закроет контейнер в конце документа; Явная очистка не требуется.
- **Дополнительный `!end<type>`**: закрывающая строка без соответствующего открытия не будет востребована этим парсером (он реагирует только тогда, когда уже находится внутри тега); Другие парсеры будут рассматривать его как обычный текст.
- **Смешанные отступы / интерлиньяжные пробелы**: Регулярные выражения open/close созданы таким образом, чтобы допускать начальные пробелы через `^\s*` (см. `BaseTag::openRegex()`/`closeRegex()`).
- **Подавленная однотипная вложенность**:когда `allowNestingSame=false`, авторы увидят внутреннее `!<type>` визуализируется в виде текста; При необходимости запишите это в руководство по разработке.

---

## Заметки о производительности
- Парсер выполняет итерацию спецификаций и выполняет одну привязку `preg_match` по спецификации для **Текущая линия**.
- Хранить `openRegex` **верный** на старте (`^`) и избегайте слишком дорогих подшаблонов.
- Количество спецификаций обычно невелико; Если он становится большим, рассмотрите возможность группировки общих префиксов или предварительного вычисления более быстрой отправки в реестре.

---

## Предложения по тестированию
Создаем светильники, покрывающие:
1. Простой блок: открыть → текст → закрыть.
2. Разбор атрибутов: в кавычках/без кавычек, `.class`, `#id`.
3. Вложенные разные теги против подавленной вложенности одного типа.
4. Однострочные теги с `closeRegex = null`.
5. Незакрытый блок в EOF.
6. Линии, напоминающие маркеры внутри кодовых ограждений (должны быть правильно проанализированы CommonMark, так как делегировано внутреннее содержимое).

---

## Устранение неполадок
- *Открыто не обнаружено*:проверять `openRegex` для тега/спецификации; Убедитесь, что строка начинается с `!type` И нет завершающих символов после атрибутов.
- *Закрыть не обнаружено*:подтверждать `closeRegex` и что линия закрытия не имеет дополнительного содержимого.
- *Отсутствуют атрибуты*: проверка именованного захвата `(?<attrs>...)` В **открытый** Регулярное выражение и ваш `Attrs` логика.
- *Неожиданный внутренний текст*: возможно, вы сталкиваетесь с однотипным подавлением вложенности; набор `allowNestingSame()`Кому`true` в вашем теге.

---

## Пример
**Уценка**
```md
!example class:"mb-4 border" .demo
Inner *markdown* content.
!endexample
```

**Результат** (упрощённо)
```html
<div class="example overflow-hidden radius-1/2 overflow-x-auto mb-4 border demo">
  <p>Inner <em>markdown</em> content.</p>
</div>
```
