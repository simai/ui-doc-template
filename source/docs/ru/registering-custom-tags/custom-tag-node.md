---
extends: _core._layouts.documentation
section: content
title: 'CustomTagNode и адаптер Spec'
description: 'CustomTagNode и адаптер Spec'
---

# CustomTagNode и адаптер Spec

На этой странице описаны следующие **Узел AST** используется для представления пользовательского тега и **адаптер** который преобразует класс тега в среду выполнения `CustomTagSpec` потребляется парсерами/рендерерами.

---

## Узел CustomTagNode (AST)
**Местоположение:** `App\Helpers\CommonMark\CustomTagNode`

Представляет собой разобранный блок пользовательских тегов в AST CommonMark.

### Конструктор
```php
public function __construct(
    private string $type,
    private array  $attrs = [],  // merged + filtered attributes
    private array  $meta  = [],  // parser metadata (e.g., openMatch, attrStr)
) {}
```

### Основные методы
- `getType(): string` — Возвращает тип тега (например, `example`).
- `isContainer(): bool` — Всегда `true`; Узел может содержать любые дочерние блоки/встроенные узлы.
- `getAttrs(): array` — Текущая карта атрибутов (объединенные значения по умолчанию + встроенные, опционально отфильтрованные).
- `setAttrs(array $attrs): void` — Заменить карту атрибутов (используется после `attrsFilter`).
- `addClass(string $class): void` — Добавить один или несколько классов; Пробелы - разделение, дедупликация, сохранение порядка для стабильных различий.
- `getMeta(): array` — Метаданные парсера (например, `['openMatch' => ..., 'attrStr' => 'class:"mb-4"']`).

> **Кончик:**Использование `getMeta()['openMatch']` в по-теге `attrsFilter($attrs, $meta)` или рендерер для получения атрибутов из именованных захватов регулярных выражений.

### Типичный жизненный цикл
1. Создание сайта **Универсальный парсер блоков** когда открытая строка совпадает с тегом `openRegex()`.
2. Атрибуты анализируются с помощью **Attrs** и объединился с `baseВлечения()`.
3. Опционально для каждого тега `attrsFilter($attrs, $meta)` может обновляться `attrs` (через `setAttrs`).
4. Рендеринг **CustomTagRenderer (Пользовательский тегРендерер)** (обёртка по умолчанию или замыкание рендерера для каждого тега).

---

## CustomTagAdapter (Тег → Spec)
**Местоположение:** `App\Helpers\CommonMark\CustomTagAdapter`

Преобразует класс тега (реализующий `CustomTagInterface` /растягивающий `BaseTag`) в неизменяемое **`CustomTagSpec`** потребляется слоем синтаксического анализа/рендеринга.

### API
```php
public static function toSpec(CustomTagInterface $tag): CustomTagSpec
```

### Обязанности
- **Извлечение удостоверений и регулярных выражений**
    - `type`:От `type()`
    - `openRegex`:От `openRegex()`; должно быть непустым, иначе будет выброшено исключение.
    - `closeRegex`:От `closeRegex()`; принуждение к `null` для однострочных тегов.
- **Перенос презентации по умолчанию**
    - `htmlTag`:От `htmlTag()` (элемент оболочки по умолчанию).
    - `baseAttrs`:От `baseAttrs()`.
- **Поведенческие флаги**
    - `allowNestingSame`:От `allowNestingSame()`.
- **Хуки для кастомизации**
    - `attrsFilter`:От `attrsFilter()`; Ожидаемая подпись `fn(array $attrs, array $meta): array`.
    - `renderer`:От `renderer()`; Ожидаемая подпись `fn(CustomTagNode $node, ChildNodeRendererInterface $children): mixed`.

### Обработка ошибок
- Если`openRegex()` возвращает пустое значение, которое выкидывает адаптер `InvalidArgumentException` идентификация тега.

---

## Как они взаимодействуют друг с другом
- Во время настройки среды каждый класс тегов преобразуется с помощью **CustomTagAdapter (Адаптер пользовательского тега)** в `CustomTagSpec` и хранятся в **CustomTagRegistry (Реестр пользовательских тегов)**.
- **Универсальный парсер блоков** Расходует технические характеристики для:
    - обнаруживать открытия/закрытия;
    - создавать **Узел пользовательского тега** с объединенными атрибутами и метой;
    - Подайте заявку заранее `attrsFilter($attrs, $meta)`.
- **CustomTagRenderer (Пользовательский тегРендерер)** Использует специализацию для следующих целей:
    - Вызов для каждого тега `renderer($node, $children)`; или
    - Рендеринг по умолчанию `HtmlElement($spec->htmlTag, $node->getAttrs(), ...)`.

---

## Шаблоны использования
- **Добавление производных классов** Во время рендеринга:
  ```php
  $node->addClass('variant-' . ($meta['openMatch']['variant'] ?? 'default'));
  ```
  Предпочитайте делать это в `attrsFilter()` для более четкого разделения проблем.

- **Однострочные теги**: Возврат пустого/ложного `closeRegex()` из бирки; Переходник пройдет `null` в спецификацию, и блок закроется сразу после открытия линии.

---

## Подводные камни и рекомендации
- Хранить `type()` глобально уникальный; Спецификации задаются по типу.
- Обеспечивать `openRegex()` предоставляет именованный объект `attrs` group, если вы ожидаете встроенные атрибуты.
- Не изменяйте атрибуты внутри рендереров без необходимости; использование `attrsFilter()` или `addClass()` на более ранних этапах потока.
- Если вы переопределите `openRegex()`/`closeRegex()`поддерживать `^` якоря и Юникод `u` модифицировать.

---

## Чек-лист для тестирования
- Создание спецификации завершается сбоем в следующих случаях: `openRegex()` пусто.
- Атрибуты узлов корректно объединяются и `addClass()` Дедупликации.
- `attrsFilter($attrs, $meta)` видит и то, и другое `openMatch` и `attrStr`.
- Путь рендерера учитывает рендерер для каждого тега и обёртку по умолчанию.

